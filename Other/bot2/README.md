### Модуль ast (Abstract Syntax Trees) в Python предоставляет инструменты для работы с абстрактным синтаксическим деревом(АСД) кода Python. 
АСД – это древовидное представление структуры кода, которое используется интерпретатором Python для
выполнения кода.

Функция literal_eval из модуля ast используется для безопасного преобразования строк, представляющих собой валидные
литералы Python (например, числа, строки, списки, словари, кортежи, множества, True, False, None), в соответствующие
объекты Python.

### Преимущества literal_eval:

Безопасность: В отличие от функции eval, которая выполняет произвольный код, переданный в виде строки, literal_eval
работает только с литералами. Это предотвращает выполнение потенциально опасного кода, который может быть передан
пользователем или получен из ненадежного источника.
Простота: literal_eval проста в использовании. Достаточно передать строку, представляющую собой валидный литерал Python,
и функция вернет соответствующий объект Python.

### Пример использования literal_eval:
```

import ast

### Строка, представляющая собой список
data = "[1, 'hello', {'key': 'value'}]"

### Преобразование строки в список с помощью literal_eval
list_data = ast.literal_eval(data)

### Вывод результата
print(list_data)  # Выведет: [1, 'hello', {'key': 'value'}]
print(type(list_data))  # Выведет: <class 'list'>
```
## Когда использовать literal_eval:

Когда нужно преобразовать строку, полученную из надежного источника (например, из конфигурационного файла или базы данных), в объект Python.
Когда нужно преобразовать строку, представляющую собой литерал Python, в объект Python без риска выполнения произвольного кода.

## Когда не использовать literal_eval:

Когда нужно выполнить произвольный код, переданный в виде строки. В этом случае используйте функцию exec (с осторожностью!).
Когда нужно преобразовать строку, полученную из ненадежного источника, в объект Python. В этом случае необходимо выполнить валидацию данных перед преобразованием.
В вашем случае, использование literal_eval оправдано, так как вы получаете строковое представление списка из callback_data, которая формируется самим ботом, а не пользователем.